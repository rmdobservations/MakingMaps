{"dependencies":[{"name":"/home/rose/projects/npmProjects/MakingMaps/node_modules/ol/package.json","includedInParent":true,"mtime":1531302262464},{"name":"/home/rose/projects/npmProjects/MakingMaps/package.json","includedInParent":true,"mtime":1531302358436},{"name":"../../../webgl.js","loc":{"line":7,"column":35},"parent":"/home/rose/projects/npmProjects/MakingMaps/node_modules/ol/render/webgl/circlereplay/defaultshader.js","resolved":"/home/rose/projects/npmProjects/MakingMaps/node_modules/ol/webgl.js"},{"name":"../../../webgl/Fragment.js","loc":{"line":8,"column":26},"parent":"/home/rose/projects/npmProjects/MakingMaps/node_modules/ol/render/webgl/circlereplay/defaultshader.js","resolved":"/home/rose/projects/npmProjects/MakingMaps/node_modules/ol/webgl/Fragment.js"},{"name":"../../../webgl/Vertex.js","loc":{"line":9,"column":24},"parent":"/home/rose/projects/npmProjects/MakingMaps/node_modules/ol/render/webgl/circlereplay/defaultshader.js","resolved":"/home/rose/projects/npmProjects/MakingMaps/node_modules/ol/webgl/Vertex.js"}],"generated":{"js":"\"use strict\";Object.defineProperty(exports,\"__esModule\",{value:!0}),exports.vertex=exports.fragment=void 0;var i=require(\"../../../webgl.js\"),e=require(\"../../../webgl/Fragment.js\"),t=a(e),o=require(\"../../../webgl/Vertex.js\"),n=a(o);function a(i){return i&&i.__esModule?i:{default:i}}const r=exports.fragment=new t.default(i.DEBUG?\"precision mediump float;\\nvarying vec2 v_center;\\nvarying vec2 v_offset;\\nvarying float v_halfWidth;\\nvarying float v_pixelRatio;\\n\\n\\n\\nuniform float u_opacity;\\nuniform vec4 u_fillColor;\\nuniform vec4 u_strokeColor;\\nuniform vec2 u_size;\\n\\nvoid main(void) {\\n  vec2 windowCenter = vec2((v_center.x + 1.0) / 2.0 * u_size.x * v_pixelRatio,\\n      (v_center.y + 1.0) / 2.0 * u_size.y * v_pixelRatio);\\n  vec2 windowOffset = vec2((v_offset.x + 1.0) / 2.0 * u_size.x * v_pixelRatio,\\n      (v_offset.y + 1.0) / 2.0 * u_size.y * v_pixelRatio);\\n  float radius = length(windowCenter - windowOffset);\\n  float dist = length(windowCenter - gl_FragCoord.xy);\\n  if (dist > radius + v_halfWidth) {\\n    if (u_strokeColor.a == 0.0) {\\n      gl_FragColor = u_fillColor;\\n    } else {\\n      gl_FragColor = u_strokeColor;\\n    }\\n    gl_FragColor.a = gl_FragColor.a - (dist - (radius + v_halfWidth));\\n  } else if (u_fillColor.a == 0.0) {\\n    // Hooray, no fill, just stroke. We can use real antialiasing.\\n    gl_FragColor = u_strokeColor;\\n    if (dist < radius - v_halfWidth) {\\n      gl_FragColor.a = gl_FragColor.a - (radius - v_halfWidth - dist);\\n    }\\n  } else {\\n    gl_FragColor = u_fillColor;\\n    float strokeDist = radius - v_halfWidth;\\n    float antialias = 2.0 * v_pixelRatio;\\n    if (dist > strokeDist) {\\n      gl_FragColor = u_strokeColor;\\n    } else if (dist >= strokeDist - antialias) {\\n      float step = smoothstep(strokeDist - antialias, strokeDist, dist);\\n      gl_FragColor = mix(u_fillColor, u_strokeColor, step);\\n    }\\n  }\\n  gl_FragColor.a = gl_FragColor.a * u_opacity;\\n  if (gl_FragColor.a <= 0.0) {\\n    discard;\\n  }\\n}\\n\":\"precision mediump float;varying vec2 a;varying vec2 b;varying float c;varying float d;uniform float m;uniform vec4 n;uniform vec4 o;uniform vec2 p;void main(void){vec2 windowCenter=vec2((a.x+1.0)/2.0*p.x*d,(a.y+1.0)/2.0*p.y*d);vec2 windowOffset=vec2((b.x+1.0)/2.0*p.x*d,(b.y+1.0)/2.0*p.y*d);float radius=length(windowCenter-windowOffset);float dist=length(windowCenter-gl_FragCoord.xy);if(dist>radius+c){if(o.a==0.0){gl_FragColor=n;}else{gl_FragColor=o;}gl_FragColor.a=gl_FragColor.a-(dist-(radius+c));}else if(n.a==0.0){gl_FragColor=o;if(dist<radius-c){gl_FragColor.a=gl_FragColor.a-(radius-c-dist);}} else{gl_FragColor=n;float strokeDist=radius-c;float antialias=2.0*d;if(dist>strokeDist){gl_FragColor=o;}else if(dist>=strokeDist-antialias){float step=smoothstep(strokeDist-antialias,strokeDist,dist);gl_FragColor=mix(n,o,step);}} gl_FragColor.a=gl_FragColor.a*m;if(gl_FragColor.a<=0.0){discard;}}\"),l=exports.vertex=new n.default(i.DEBUG?\"varying vec2 v_center;\\nvarying vec2 v_offset;\\nvarying float v_halfWidth;\\nvarying float v_pixelRatio;\\n\\n\\nattribute vec2 a_position;\\nattribute float a_instruction;\\nattribute float a_radius;\\n\\nuniform mat4 u_projectionMatrix;\\nuniform mat4 u_offsetScaleMatrix;\\nuniform mat4 u_offsetRotateMatrix;\\nuniform float u_lineWidth;\\nuniform float u_pixelRatio;\\n\\nvoid main(void) {\\n  mat4 offsetMatrix = u_offsetScaleMatrix * u_offsetRotateMatrix;\\n  v_center = vec4(u_projectionMatrix * vec4(a_position, 0.0, 1.0)).xy;\\n  v_pixelRatio = u_pixelRatio;\\n  float lineWidth = u_lineWidth * u_pixelRatio;\\n  v_halfWidth = lineWidth / 2.0;\\n  if (lineWidth == 0.0) {\\n    lineWidth = 2.0 * u_pixelRatio;\\n  }\\n  vec2 offset;\\n  // Radius with anitaliasing (roughly).\\n  float radius = a_radius + 3.0 * u_pixelRatio;\\n  // Until we get gl_VertexID in WebGL, we store an instruction.\\n  if (a_instruction == 0.0) {\\n    // Offsetting the edges of the triangle by lineWidth / 2 is necessary, however\\n    // we should also leave some space for the antialiasing, thus we offset by lineWidth.\\n    offset = vec2(-1.0, 1.0);\\n  } else if (a_instruction == 1.0) {\\n    offset = vec2(-1.0, -1.0);\\n  } else if (a_instruction == 2.0) {\\n    offset = vec2(1.0, -1.0);\\n  } else {\\n    offset = vec2(1.0, 1.0);\\n  }\\n\\n  gl_Position = u_projectionMatrix * vec4(a_position + offset * radius, 0.0, 1.0) +\\n      offsetMatrix * vec4(offset * lineWidth, 0.0, 0.0);\\n  v_offset = vec4(u_projectionMatrix * vec4(a_position.x + a_radius, a_position.y,\\n      0.0, 1.0)).xy;\\n\\n  if (distance(v_center, v_offset) > 20000.0) {\\n    gl_Position = vec4(v_center, 0.0, 1.0);\\n  }\\n}\\n\\n\\n\":\"varying vec2 a;varying vec2 b;varying float c;varying float d;attribute vec2 e;attribute float f;attribute float g;uniform mat4 h;uniform mat4 i;uniform mat4 j;uniform float k;uniform float l;void main(void){mat4 offsetMatrix=i*j;a=vec4(h*vec4(e,0.0,1.0)).xy;d=l;float lineWidth=k*l;c=lineWidth/2.0;if(lineWidth==0.0){lineWidth=2.0*l;}vec2 offset;float radius=g+3.0*l;if(f==0.0){offset=vec2(-1.0,1.0);}else if(f==1.0){offset=vec2(-1.0,-1.0);}else if(f==2.0){offset=vec2(1.0,-1.0);}else{offset=vec2(1.0,1.0);}gl_Position=h*vec4(e+offset*radius,0.0,1.0)+offsetMatrix*vec4(offset*lineWidth,0.0,0.0);b=vec4(h*vec4(e.x+g,e.y,0.0,1.0)).xy;if(distance(a,b)>20000.0){gl_Position=vec4(a,0.0,1.0);}}\");","map":{"mappings":[{"source":"node_modules/ol/render/webgl/circlereplay/defaultshader.js","original":{"line":15,"column":7},"generated":{"line":1,"column":0}},{"source":"node_modules/ol/render/webgl/circlereplay/defaultshader.js","original":{"line":15,"column":7},"generated":{"line":1,"column":13}},{"source":"node_modules/ol/render/webgl/circlereplay/defaultshader.js","original":{"line":15,"column":7},"generated":{"line":1,"column":20}},{"source":"node_modules/ol/render/webgl/circlereplay/defaultshader.js","original":{"line":15,"column":7},"generated":{"line":1,"column":35}},{"source":"node_modules/ol/render/webgl/circlereplay/defaultshader.js","original":{"line":15,"column":7},"generated":{"line":1,"column":43}},{"source":"node_modules/ol/render/webgl/circlereplay/defaultshader.js","original":{"line":15,"column":7},"generated":{"line":1,"column":56}},{"source":"node_modules/ol/render/webgl/circlereplay/defaultshader.js","original":{"line":15,"column":7},"generated":{"line":1,"column":57}},{"source":"node_modules/ol/render/webgl/circlereplay/defaultshader.js","original":{"line":15,"column":7},"generated":{"line":1,"column":64}},{"source":"node_modules/ol/render/webgl/circlereplay/defaultshader.js","original":{"line":15,"column":7},"generated":{"line":1,"column":68}},{"source":"node_modules/ol/render/webgl/circlereplay/defaultshader.js","original":{"line":15,"column":7},"generated":{"line":1,"column":76}},{"source":"node_modules/ol/render/webgl/circlereplay/defaultshader.js","original":{"line":15,"column":7},"generated":{"line":1,"column":83}},{"source":"node_modules/ol/render/webgl/circlereplay/defaultshader.js","original":{"line":15,"column":7},"generated":{"line":1,"column":91}},{"source":"node_modules/ol/render/webgl/circlereplay/defaultshader.js","original":{"line":15,"column":7},"generated":{"line":1,"column":105}},{"source":"node_modules/ol/render/webgl/circlereplay/defaultshader.js","original":{"line":7,"column":0},"generated":{"line":1,"column":107}},{"source":"node_modules/ol/render/webgl/circlereplay/defaultshader.js","original":{"line":7,"column":0},"generated":{"line":1,"column":111}},{"source":"node_modules/ol/render/webgl/circlereplay/defaultshader.js","original":{"line":7,"column":0},"generated":{"line":1,"column":113}},{"source":"node_modules/ol/render/webgl/circlereplay/defaultshader.js","original":{"line":7,"column":0},"generated":{"line":1,"column":121}},{"source":"node_modules/ol/render/webgl/circlereplay/defaultshader.js","original":{"line":8,"column":0},"generated":{"line":1,"column":142}},{"source":"node_modules/ol/render/webgl/circlereplay/defaultshader.js","original":{"line":8,"column":0},"generated":{"line":1,"column":144}},{"source":"node_modules/ol/render/webgl/circlereplay/defaultshader.js","original":{"line":8,"column":0},"generated":{"line":1,"column":152}},{"source":"node_modules/ol/render/webgl/circlereplay/defaultshader.js","original":{"line":15,"column":7},"generated":{"line":1,"column":182}},{"source":"node_modules/ol/render/webgl/circlereplay/defaultshader.js","original":{"line":15,"column":7},"generated":{"line":1,"column":184}},{"source":"node_modules/ol/render/webgl/circlereplay/defaultshader.js","original":{"line":15,"column":7},"generated":{"line":1,"column":186}},{"source":"node_modules/ol/render/webgl/circlereplay/defaultshader.js","original":{"line":9,"column":0},"generated":{"line":1,"column":189}},{"source":"node_modules/ol/render/webgl/circlereplay/defaultshader.js","original":{"line":9,"column":0},"generated":{"line":1,"column":191}},{"source":"node_modules/ol/render/webgl/circlereplay/defaultshader.js","original":{"line":9,"column":0},"generated":{"line":1,"column":199}},{"source":"node_modules/ol/render/webgl/circlereplay/defaultshader.js","original":{"line":15,"column":7},"generated":{"line":1,"column":227}},{"source":"node_modules/ol/render/webgl/circlereplay/defaultshader.js","original":{"line":15,"column":7},"generated":{"line":1,"column":229}},{"source":"node_modules/ol/render/webgl/circlereplay/defaultshader.js","original":{"line":15,"column":7},"generated":{"line":1,"column":231}},{"source":"node_modules/ol/render/webgl/circlereplay/defaultshader.js","original":{"line":15,"column":7},"generated":{"line":1,"column":234}},{"source":"node_modules/ol/render/webgl/circlereplay/defaultshader.js","original":{"line":15,"column":7},"generated":{"line":1,"column":243}},{"source":"node_modules/ol/render/webgl/circlereplay/defaultshader.js","original":{"line":15,"column":7},"generated":{"line":1,"column":245}},{"source":"node_modules/ol/render/webgl/circlereplay/defaultshader.js","original":{"line":15,"column":7},"generated":{"line":1,"column":248}},{"source":"node_modules/ol/render/webgl/circlereplay/defaultshader.js","original":{"line":15,"column":7},"generated":{"line":1,"column":255}},{"source":"node_modules/ol/render/webgl/circlereplay/defaultshader.js","original":{"line":15,"column":7},"generated":{"line":1,"column":258}},{"source":"node_modules/ol/render/webgl/circlereplay/defaultshader.js","original":{"line":15,"column":7},"generated":{"line":1,"column":260}},{"source":"node_modules/ol/render/webgl/circlereplay/defaultshader.js","original":{"line":15,"column":7},"generated":{"line":1,"column":271}},{"source":"node_modules/ol/render/webgl/circlereplay/defaultshader.js","original":{"line":15,"column":7},"generated":{"line":1,"column":273}},{"source":"node_modules/ol/render/webgl/circlereplay/defaultshader.js","original":{"line":15,"column":7},"generated":{"line":1,"column":274}},{"source":"node_modules/ol/render/webgl/circlereplay/defaultshader.js","original":{"line":15,"column":7},"generated":{"line":1,"column":282}},{"source":"node_modules/ol/render/webgl/circlereplay/defaultshader.js","original":{"line":11,"column":7},"generated":{"line":1,"column":285}},{"source":"node_modules/ol/render/webgl/circlereplay/defaultshader.js","name":"fragment","original":{"line":11,"column":13},"generated":{"line":1,"column":291}},{"source":"node_modules/ol/render/webgl/circlereplay/defaultshader.js","original":{"line":11,"column":24},"generated":{"line":1,"column":293}},{"source":"node_modules/ol/render/webgl/circlereplay/defaultshader.js","original":{"line":11,"column":24},"generated":{"line":1,"column":301}},{"source":"node_modules/ol/render/webgl/circlereplay/defaultshader.js","original":{"line":11,"column":24},"generated":{"line":1,"column":310}},{"source":"node_modules/ol/render/webgl/circlereplay/defaultshader.js","name":"WebGLFragment","original":{"line":11,"column":28},"generated":{"line":1,"column":314}},{"source":"node_modules/ol/render/webgl/circlereplay/defaultshader.js","original":{"line":11,"column":24},"generated":{"line":1,"column":316}},{"source":"node_modules/ol/render/webgl/circlereplay/defaultshader.js","name":"DEBUG_WEBGL","original":{"line":11,"column":42},"generated":{"line":1,"column":324}},{"source":"node_modules/ol/render/webgl/circlereplay/defaultshader.js","original":{"line":12,"column":2},"generated":{"line":1,"column":326}},{"source":"node_modules/ol/render/webgl/circlereplay/defaultshader.js","original":{"line":12,"column":2},"generated":{"line":1,"column":332}},{"source":"node_modules/ol/render/webgl/circlereplay/defaultshader.js","original":{"line":13,"column":2},"generated":{"line":1,"column":1986}},{"source":"node_modules/ol/render/webgl/circlereplay/defaultshader.js","name":"vertex","original":{"line":15,"column":13},"generated":{"line":1,"column":2889}},{"source":"node_modules/ol/render/webgl/circlereplay/defaultshader.js","original":{"line":15,"column":22},"generated":{"line":1,"column":2891}},{"source":"node_modules/ol/render/webgl/circlereplay/defaultshader.js","original":{"line":15,"column":22},"generated":{"line":1,"column":2899}},{"source":"node_modules/ol/render/webgl/circlereplay/defaultshader.js","original":{"line":15,"column":22},"generated":{"line":1,"column":2906}},{"source":"node_modules/ol/render/webgl/circlereplay/defaultshader.js","name":"WebGLVertex","original":{"line":15,"column":26},"generated":{"line":1,"column":2910}},{"source":"node_modules/ol/render/webgl/circlereplay/defaultshader.js","original":{"line":15,"column":22},"generated":{"line":1,"column":2912}},{"source":"node_modules/ol/render/webgl/circlereplay/defaultshader.js","name":"DEBUG_WEBGL","original":{"line":15,"column":38},"generated":{"line":1,"column":2920}},{"source":"node_modules/ol/render/webgl/circlereplay/defaultshader.js","original":{"line":16,"column":2},"generated":{"line":1,"column":2922}},{"source":"node_modules/ol/render/webgl/circlereplay/defaultshader.js","original":{"line":16,"column":2},"generated":{"line":1,"column":2928}},{"source":"node_modules/ol/render/webgl/circlereplay/defaultshader.js","original":{"line":17,"column":2},"generated":{"line":1,"column":4590}}],"sources":{"node_modules/ol/render/webgl/circlereplay/defaultshader.js":"/**\n * @module ol/render/webgl/circlereplay/defaultshader\n */\n// This file is automatically generated, do not edit.\n// Run `make shaders` to generate, and commit the result.\n\nimport {DEBUG as DEBUG_WEBGL} from '../../../webgl.js';\nimport WebGLFragment from '../../../webgl/Fragment.js';\nimport WebGLVertex from '../../../webgl/Vertex.js';\n\nexport const fragment = new WebGLFragment(DEBUG_WEBGL ?\n  'precision mediump float;\\nvarying vec2 v_center;\\nvarying vec2 v_offset;\\nvarying float v_halfWidth;\\nvarying float v_pixelRatio;\\n\\n\\n\\nuniform float u_opacity;\\nuniform vec4 u_fillColor;\\nuniform vec4 u_strokeColor;\\nuniform vec2 u_size;\\n\\nvoid main(void) {\\n  vec2 windowCenter = vec2((v_center.x + 1.0) / 2.0 * u_size.x * v_pixelRatio,\\n      (v_center.y + 1.0) / 2.0 * u_size.y * v_pixelRatio);\\n  vec2 windowOffset = vec2((v_offset.x + 1.0) / 2.0 * u_size.x * v_pixelRatio,\\n      (v_offset.y + 1.0) / 2.0 * u_size.y * v_pixelRatio);\\n  float radius = length(windowCenter - windowOffset);\\n  float dist = length(windowCenter - gl_FragCoord.xy);\\n  if (dist > radius + v_halfWidth) {\\n    if (u_strokeColor.a == 0.0) {\\n      gl_FragColor = u_fillColor;\\n    } else {\\n      gl_FragColor = u_strokeColor;\\n    }\\n    gl_FragColor.a = gl_FragColor.a - (dist - (radius + v_halfWidth));\\n  } else if (u_fillColor.a == 0.0) {\\n    // Hooray, no fill, just stroke. We can use real antialiasing.\\n    gl_FragColor = u_strokeColor;\\n    if (dist < radius - v_halfWidth) {\\n      gl_FragColor.a = gl_FragColor.a - (radius - v_halfWidth - dist);\\n    }\\n  } else {\\n    gl_FragColor = u_fillColor;\\n    float strokeDist = radius - v_halfWidth;\\n    float antialias = 2.0 * v_pixelRatio;\\n    if (dist > strokeDist) {\\n      gl_FragColor = u_strokeColor;\\n    } else if (dist >= strokeDist - antialias) {\\n      float step = smoothstep(strokeDist - antialias, strokeDist, dist);\\n      gl_FragColor = mix(u_fillColor, u_strokeColor, step);\\n    }\\n  }\\n  gl_FragColor.a = gl_FragColor.a * u_opacity;\\n  if (gl_FragColor.a <= 0.0) {\\n    discard;\\n  }\\n}\\n' :\n  'precision mediump float;varying vec2 a;varying vec2 b;varying float c;varying float d;uniform float m;uniform vec4 n;uniform vec4 o;uniform vec2 p;void main(void){vec2 windowCenter=vec2((a.x+1.0)/2.0*p.x*d,(a.y+1.0)/2.0*p.y*d);vec2 windowOffset=vec2((b.x+1.0)/2.0*p.x*d,(b.y+1.0)/2.0*p.y*d);float radius=length(windowCenter-windowOffset);float dist=length(windowCenter-gl_FragCoord.xy);if(dist>radius+c){if(o.a==0.0){gl_FragColor=n;}else{gl_FragColor=o;}gl_FragColor.a=gl_FragColor.a-(dist-(radius+c));}else if(n.a==0.0){gl_FragColor=o;if(dist<radius-c){gl_FragColor.a=gl_FragColor.a-(radius-c-dist);}} else{gl_FragColor=n;float strokeDist=radius-c;float antialias=2.0*d;if(dist>strokeDist){gl_FragColor=o;}else if(dist>=strokeDist-antialias){float step=smoothstep(strokeDist-antialias,strokeDist,dist);gl_FragColor=mix(n,o,step);}} gl_FragColor.a=gl_FragColor.a*m;if(gl_FragColor.a<=0.0){discard;}}');\n\nexport const vertex = new WebGLVertex(DEBUG_WEBGL ?\n  'varying vec2 v_center;\\nvarying vec2 v_offset;\\nvarying float v_halfWidth;\\nvarying float v_pixelRatio;\\n\\n\\nattribute vec2 a_position;\\nattribute float a_instruction;\\nattribute float a_radius;\\n\\nuniform mat4 u_projectionMatrix;\\nuniform mat4 u_offsetScaleMatrix;\\nuniform mat4 u_offsetRotateMatrix;\\nuniform float u_lineWidth;\\nuniform float u_pixelRatio;\\n\\nvoid main(void) {\\n  mat4 offsetMatrix = u_offsetScaleMatrix * u_offsetRotateMatrix;\\n  v_center = vec4(u_projectionMatrix * vec4(a_position, 0.0, 1.0)).xy;\\n  v_pixelRatio = u_pixelRatio;\\n  float lineWidth = u_lineWidth * u_pixelRatio;\\n  v_halfWidth = lineWidth / 2.0;\\n  if (lineWidth == 0.0) {\\n    lineWidth = 2.0 * u_pixelRatio;\\n  }\\n  vec2 offset;\\n  // Radius with anitaliasing (roughly).\\n  float radius = a_radius + 3.0 * u_pixelRatio;\\n  // Until we get gl_VertexID in WebGL, we store an instruction.\\n  if (a_instruction == 0.0) {\\n    // Offsetting the edges of the triangle by lineWidth / 2 is necessary, however\\n    // we should also leave some space for the antialiasing, thus we offset by lineWidth.\\n    offset = vec2(-1.0, 1.0);\\n  } else if (a_instruction == 1.0) {\\n    offset = vec2(-1.0, -1.0);\\n  } else if (a_instruction == 2.0) {\\n    offset = vec2(1.0, -1.0);\\n  } else {\\n    offset = vec2(1.0, 1.0);\\n  }\\n\\n  gl_Position = u_projectionMatrix * vec4(a_position + offset * radius, 0.0, 1.0) +\\n      offsetMatrix * vec4(offset * lineWidth, 0.0, 0.0);\\n  v_offset = vec4(u_projectionMatrix * vec4(a_position.x + a_radius, a_position.y,\\n      0.0, 1.0)).xy;\\n\\n  if (distance(v_center, v_offset) > 20000.0) {\\n    gl_Position = vec4(v_center, 0.0, 1.0);\\n  }\\n}\\n\\n\\n' :\n  'varying vec2 a;varying vec2 b;varying float c;varying float d;attribute vec2 e;attribute float f;attribute float g;uniform mat4 h;uniform mat4 i;uniform mat4 j;uniform float k;uniform float l;void main(void){mat4 offsetMatrix=i*j;a=vec4(h*vec4(e,0.0,1.0)).xy;d=l;float lineWidth=k*l;c=lineWidth/2.0;if(lineWidth==0.0){lineWidth=2.0*l;}vec2 offset;float radius=g+3.0*l;if(f==0.0){offset=vec2(-1.0,1.0);}else if(f==1.0){offset=vec2(-1.0,-1.0);}else if(f==2.0){offset=vec2(1.0,-1.0);}else{offset=vec2(1.0,1.0);}gl_Position=h*vec4(e+offset*radius,0.0,1.0)+offsetMatrix*vec4(offset*lineWidth,0.0,0.0);b=vec4(h*vec4(e.x+g,e.y,0.0,1.0)).xy;if(distance(a,b)>20000.0){gl_Position=vec4(a,0.0,1.0);}}');\n"},"lineCount":null}},"hash":"c124a9d903b0e9e70096fc5598a3f10a","cacheData":{"env":{}},"id":288}